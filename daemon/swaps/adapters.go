package swaps

import (
	"context"
	"fmt"

	"github.com/40acres/40swap/daemon/database/models"
	"github.com/40acres/40swap/daemon/money"
	"github.com/lightningnetwork/lnd/lntypes"
)

// DaemonSwapOutMonitorAdapter adapts the daemon's SwapMonitor methods
type DaemonSwapOutMonitorAdapter struct {
	monitor interface {
		MonitorSwapOut(ctx context.Context, swap *models.SwapOut) error
		ClaimSwapOut(ctx context.Context, swap *models.SwapOut) (string, error)
	}
}

// NewDaemonSwapOutMonitorAdapter creates a new adapter for daemon swap out monitoring
func NewDaemonSwapOutMonitorAdapter(monitor interface {
	MonitorSwapOut(ctx context.Context, swap *models.SwapOut) error
	ClaimSwapOut(ctx context.Context, swap *models.SwapOut) (string, error)
}) *DaemonSwapOutMonitorAdapter {
	return &DaemonSwapOutMonitorAdapter{monitor: monitor}
}

// RPCSwapOutCreatorAdapter adapts the RPC server's SwapOut method for auto swap
type RPCSwapOutCreatorAdapter struct {
	server interface {
		SwapOut(ctx context.Context, req interface{}) (interface{}, error)
	}
}

// NewRPCSwapOutCreatorAdapter creates a new adapter for RPC swap out creation
func NewRPCSwapOutCreatorAdapter(server interface {
	SwapOut(ctx context.Context, req interface{}) (interface{}, error)
}) *RPCSwapOutCreatorAdapter {
	return &RPCSwapOutCreatorAdapter{server: server}
}

// MonitorSwapOut implements SwapOutMonitor interface
func (a *DaemonSwapOutMonitorAdapter) MonitorSwapOut(ctx context.Context, swap *models.SwapOut) error {
	return a.monitor.MonitorSwapOut(ctx, swap)
}

// ClaimSwapOut implements SwapOutMonitor interface
func (a *DaemonSwapOutMonitorAdapter) ClaimSwapOut(ctx context.Context, swap *models.SwapOut) (string, error) {
	return a.monitor.ClaimSwapOut(ctx, swap)
}

// CreateSwapOut implements SwapOutCreator interface by adapting SwapOut
func (a *RPCSwapOutCreatorAdapter) CreateSwapOut(ctx context.Context, claimPubKey string, amountSats money.Money) (*SwapOutResponse, *lntypes.Preimage, error) {
	// Create a request map with the required parameters
	req := map[string]interface{}{
		"chain":      1, // BITCOIN
		"amountSats": uint64(amountSats),
		"address":    "", // Will be generated by the SwapOut function
	}

	// Call the SwapOut function
	resp, err := a.server.SwapOut(ctx, req)
	if err != nil {
		return nil, nil, err
	}

	// Convert the response to the expected format
	// Extract SwapId from the response
	respMap, ok := resp.(map[string]interface{})
	if !ok {
		return nil, nil, fmt.Errorf("unexpected response type")
	}

	swapId, idOk := respMap["swapId"].(string)
	if !idOk {
		return nil, nil, fmt.Errorf("swapId not found in response")
	}

	amountSats, amountOk := respMap["amountSats"].(money.Money)
	if !amountOk {
		return nil, nil, fmt.Errorf("amountSats not found in response")
	}

	// Create a minimal SwapOutResponse
	swapResponse := &SwapOutResponse{
		SwapId: swapId,
	}

	// We can't get the preimage from the RPC response, so we'll return nil
	// The auto swap logic should handle this case
	return swapResponse, nil, nil
}
