// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/40acres/40swap/daemon/database/models"
)

func newSwapIn(db *gorm.DB, opts ...gen.DOOption) swapIn {
	_swapIn := swapIn{}

	_swapIn.swapInDo.UseDB(db, opts...)
	_swapIn.swapInDo.UseModel(&models.SwapIn{})

	tableName := _swapIn.swapInDo.TableName()
	_swapIn.ALL = field.NewAsterisk(tableName)
	_swapIn.ID = field.NewInt64(tableName, "id")
	_swapIn.SwapID = field.NewString(tableName, "swap_id")
	_swapIn.AmountSats = field.NewInt64(tableName, "amount_sats")
	_swapIn.Status = field.NewField(tableName, "status")
	_swapIn.Outcome = field.NewField(tableName, "outcome")
	_swapIn.SourceChain = field.NewField(tableName, "source_chain")
	_swapIn.ClaimAddress = field.NewString(tableName, "claim_address")
	_swapIn.ClaimTxID = field.NewString(tableName, "claim_tx_id")
	_swapIn.TimeoutBlockHeight = field.NewInt64(tableName, "timeout_block_height")
	_swapIn.RefundAddress = field.NewString(tableName, "refund_address")
	_swapIn.RefundTxID = field.NewString(tableName, "refund_tx_id")
	_swapIn.RefundPrivatekey = field.NewString(tableName, "refund_privatekey")
	_swapIn.RedeemScript = field.NewString(tableName, "redeem_script")
	_swapIn.PaymentRequest = field.NewString(tableName, "payment_request")
	_swapIn.PreImage = field.NewField(tableName, "pre_image")
	_swapIn.OnChainFeeSats = field.NewInt64(tableName, "on_chain_fee_sats")
	_swapIn.ServiceFeeSats = field.NewInt64(tableName, "service_fee_sats")
	_swapIn.CreatedAt = field.NewTime(tableName, "created_at")
	_swapIn.UpdatedAt = field.NewTime(tableName, "updated_at")

	_swapIn.fillFieldMap()

	return _swapIn
}

type swapIn struct {
	swapInDo swapInDo

	ALL                field.Asterisk
	ID                 field.Int64
	SwapID             field.String
	AmountSats         field.Int64
	Status             field.Field
	Outcome            field.Field
	SourceChain        field.Field
	ClaimAddress       field.String
	ClaimTxID          field.String
	TimeoutBlockHeight field.Int64
	RefundAddress      field.String
	RefundTxID         field.String
	RefundPrivatekey   field.String
	RedeemScript       field.String
	PaymentRequest     field.String
	PreImage           field.Field
	OnChainFeeSats     field.Int64
	ServiceFeeSats     field.Int64
	CreatedAt          field.Time
	UpdatedAt          field.Time

	fieldMap map[string]field.Expr
}

func (s swapIn) Table(newTableName string) *swapIn {
	s.swapInDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s swapIn) As(alias string) *swapIn {
	s.swapInDo.DO = *(s.swapInDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *swapIn) updateTableName(table string) *swapIn {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.SwapID = field.NewString(table, "swap_id")
	s.AmountSats = field.NewInt64(table, "amount_sats")
	s.Status = field.NewField(table, "status")
	s.Outcome = field.NewField(table, "outcome")
	s.SourceChain = field.NewField(table, "source_chain")
	s.ClaimAddress = field.NewString(table, "claim_address")
	s.ClaimTxID = field.NewString(table, "claim_tx_id")
	s.TimeoutBlockHeight = field.NewInt64(table, "timeout_block_height")
	s.RefundAddress = field.NewString(table, "refund_address")
	s.RefundTxID = field.NewString(table, "refund_tx_id")
	s.RefundPrivatekey = field.NewString(table, "refund_privatekey")
	s.RedeemScript = field.NewString(table, "redeem_script")
	s.PaymentRequest = field.NewString(table, "payment_request")
	s.PreImage = field.NewField(table, "pre_image")
	s.OnChainFeeSats = field.NewInt64(table, "on_chain_fee_sats")
	s.ServiceFeeSats = field.NewInt64(table, "service_fee_sats")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")

	s.fillFieldMap()

	return s
}

func (s *swapIn) WithContext(ctx context.Context) ISwapInDo { return s.swapInDo.WithContext(ctx) }

func (s swapIn) TableName() string { return s.swapInDo.TableName() }

func (s swapIn) Alias() string { return s.swapInDo.Alias() }

func (s swapIn) Columns(cols ...field.Expr) gen.Columns { return s.swapInDo.Columns(cols...) }

func (s *swapIn) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *swapIn) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 19)
	s.fieldMap["id"] = s.ID
	s.fieldMap["swap_id"] = s.SwapID
	s.fieldMap["amount_sats"] = s.AmountSats
	s.fieldMap["status"] = s.Status
	s.fieldMap["outcome"] = s.Outcome
	s.fieldMap["source_chain"] = s.SourceChain
	s.fieldMap["claim_address"] = s.ClaimAddress
	s.fieldMap["claim_tx_id"] = s.ClaimTxID
	s.fieldMap["timeout_block_height"] = s.TimeoutBlockHeight
	s.fieldMap["refund_address"] = s.RefundAddress
	s.fieldMap["refund_tx_id"] = s.RefundTxID
	s.fieldMap["refund_privatekey"] = s.RefundPrivatekey
	s.fieldMap["redeem_script"] = s.RedeemScript
	s.fieldMap["payment_request"] = s.PaymentRequest
	s.fieldMap["pre_image"] = s.PreImage
	s.fieldMap["on_chain_fee_sats"] = s.OnChainFeeSats
	s.fieldMap["service_fee_sats"] = s.ServiceFeeSats
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
}

func (s swapIn) clone(db *gorm.DB) swapIn {
	s.swapInDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s swapIn) replaceDB(db *gorm.DB) swapIn {
	s.swapInDo.ReplaceDB(db)
	return s
}

type swapInDo struct{ gen.DO }

type ISwapInDo interface {
	gen.SubQuery
	Debug() ISwapInDo
	WithContext(ctx context.Context) ISwapInDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISwapInDo
	WriteDB() ISwapInDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISwapInDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISwapInDo
	Not(conds ...gen.Condition) ISwapInDo
	Or(conds ...gen.Condition) ISwapInDo
	Select(conds ...field.Expr) ISwapInDo
	Where(conds ...gen.Condition) ISwapInDo
	Order(conds ...field.Expr) ISwapInDo
	Distinct(cols ...field.Expr) ISwapInDo
	Omit(cols ...field.Expr) ISwapInDo
	Join(table schema.Tabler, on ...field.Expr) ISwapInDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISwapInDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISwapInDo
	Group(cols ...field.Expr) ISwapInDo
	Having(conds ...gen.Condition) ISwapInDo
	Limit(limit int) ISwapInDo
	Offset(offset int) ISwapInDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISwapInDo
	Unscoped() ISwapInDo
	Create(values ...*models.SwapIn) error
	CreateInBatches(values []*models.SwapIn, batchSize int) error
	Save(values ...*models.SwapIn) error
	First() (*models.SwapIn, error)
	Take() (*models.SwapIn, error)
	Last() (*models.SwapIn, error)
	Find() ([]*models.SwapIn, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.SwapIn, err error)
	FindInBatches(result *[]*models.SwapIn, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.SwapIn) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISwapInDo
	Assign(attrs ...field.AssignExpr) ISwapInDo
	Joins(fields ...field.RelationField) ISwapInDo
	Preload(fields ...field.RelationField) ISwapInDo
	FirstOrInit() (*models.SwapIn, error)
	FirstOrCreate() (*models.SwapIn, error)
	FindByPage(offset int, limit int) (result []*models.SwapIn, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISwapInDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s swapInDo) Debug() ISwapInDo {
	return s.withDO(s.DO.Debug())
}

func (s swapInDo) WithContext(ctx context.Context) ISwapInDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s swapInDo) ReadDB() ISwapInDo {
	return s.Clauses(dbresolver.Read)
}

func (s swapInDo) WriteDB() ISwapInDo {
	return s.Clauses(dbresolver.Write)
}

func (s swapInDo) Session(config *gorm.Session) ISwapInDo {
	return s.withDO(s.DO.Session(config))
}

func (s swapInDo) Clauses(conds ...clause.Expression) ISwapInDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s swapInDo) Returning(value interface{}, columns ...string) ISwapInDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s swapInDo) Not(conds ...gen.Condition) ISwapInDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s swapInDo) Or(conds ...gen.Condition) ISwapInDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s swapInDo) Select(conds ...field.Expr) ISwapInDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s swapInDo) Where(conds ...gen.Condition) ISwapInDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s swapInDo) Order(conds ...field.Expr) ISwapInDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s swapInDo) Distinct(cols ...field.Expr) ISwapInDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s swapInDo) Omit(cols ...field.Expr) ISwapInDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s swapInDo) Join(table schema.Tabler, on ...field.Expr) ISwapInDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s swapInDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISwapInDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s swapInDo) RightJoin(table schema.Tabler, on ...field.Expr) ISwapInDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s swapInDo) Group(cols ...field.Expr) ISwapInDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s swapInDo) Having(conds ...gen.Condition) ISwapInDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s swapInDo) Limit(limit int) ISwapInDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s swapInDo) Offset(offset int) ISwapInDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s swapInDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISwapInDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s swapInDo) Unscoped() ISwapInDo {
	return s.withDO(s.DO.Unscoped())
}

func (s swapInDo) Create(values ...*models.SwapIn) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s swapInDo) CreateInBatches(values []*models.SwapIn, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s swapInDo) Save(values ...*models.SwapIn) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s swapInDo) First() (*models.SwapIn, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.SwapIn), nil
	}
}

func (s swapInDo) Take() (*models.SwapIn, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.SwapIn), nil
	}
}

func (s swapInDo) Last() (*models.SwapIn, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.SwapIn), nil
	}
}

func (s swapInDo) Find() ([]*models.SwapIn, error) {
	result, err := s.DO.Find()
	return result.([]*models.SwapIn), err
}

func (s swapInDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.SwapIn, err error) {
	buf := make([]*models.SwapIn, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s swapInDo) FindInBatches(result *[]*models.SwapIn, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s swapInDo) Attrs(attrs ...field.AssignExpr) ISwapInDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s swapInDo) Assign(attrs ...field.AssignExpr) ISwapInDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s swapInDo) Joins(fields ...field.RelationField) ISwapInDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s swapInDo) Preload(fields ...field.RelationField) ISwapInDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s swapInDo) FirstOrInit() (*models.SwapIn, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.SwapIn), nil
	}
}

func (s swapInDo) FirstOrCreate() (*models.SwapIn, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.SwapIn), nil
	}
}

func (s swapInDo) FindByPage(offset int, limit int) (result []*models.SwapIn, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s swapInDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s swapInDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s swapInDo) Delete(models ...*models.SwapIn) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *swapInDo) withDO(do gen.Dao) *swapInDo {
	s.DO = *do.(*gen.DO)
	return s
}
